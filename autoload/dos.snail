proc dos.make83 {$name} {
	arg.must.quoted name
	if {string.contains $name "/"} then {return [dos.make83.path $name]}
	set parts [string.split $name "."]
	set nparts [list.length $parts]
	if {or {< $nparts 1} {> $nparts 2}} then {error [string.concat "Name cannot be converted to DOS 8.3 format: " [token.quote $name]]}
	set r [string.upper [string.left [list.at $parts 0] 8]]
	if {= $nparts 2} then {set r [string.concat $r "." [string.upper [string.left [list.at $parts 1] 3]]]}
	pass $r
}

proc dos.make83.path {$path} {
	arg.must.quoted path
	set names [string.split $path "/"]
	set result {}
	foreach name $names {set result [list.add $result [dos.make83 $name]]}
	string.join $result "/"
}

proc dos.make83.paths {$paths} {
	arg.must.list paths
	set map %{}
	foreach path $paths {set map [dict.set $map $path [dos.make83 $path]]}
	set dups [dict.find.duplicate.values $map]
	if {> [dict.size $dups] 0} then {
		error [string.concat "DOS 8.3 paths are not unique: " $dups]
	}
	pass $map
}

proc dos.version {} {
	set r [dos.int86 [hex 21] [dict ah [hex 30]]]
	set major [dict.get $r al]
	set minor [dict.get $r ah]
	string.concat $major "." $minor
}

proc dos.key.installed {} {
	set r [dos.int86 [hex 2f] [dict ax [hex 4800]]]
	not [= 0 [dict.get $r al]]
}

proc dos.key.read {} {
	set mem.buf [dos.mem.alloc 130]
	set mem.seg [channel.control $mem.buf {segment}]
	channel.control $mem.buf [list byte.set 0 [hex 80]]
	set result [dos.int86 [hex 2f] [dict ax [hex 4810] ds $mem.seg]]
	if {not [= [dict.get $result ax] 0]} then {
		channel.close $mem.buf
		error "dos.key.read: DOSKEY call (INT 0x2F,AX=0x4810) failed"
	}
	set bytes [channel.control $mem.buf {byte.get 1}]
	if {= 0 $bytes} then {
		channel.close $mem.buf
		puts ""
		return ""
	}
	channel.control $mem.buf [list byte.set 0 [hex 20]]
	channel.control $mem.buf [list byte.set 1 [hex 20]]
	channel.control $mem.buf [list byte.set [+ $bytes 2] 0]
	set read [channel.read $mem.buf 144]
	channel.close $mem.buf
	puts ""
	set r [string.skip $read 2]
	if {= $r [string.chr 26]} then {return [null]}
	pass $r
}

proc dos.snail.init {} {
	if {dos.key.installed} then {
		repl.read.script.set {dos.key.read}
	}
}
