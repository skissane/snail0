proc dos.make83 {$name} {
	arg.must.quoted name
	if {string.contains $name "/"} then {return [dos.make83.path $name]}
	set parts [string.split $name "."]
	set nparts [list.length $parts]
	if {or {< $nparts 1} {> $nparts 2}} then {error [string.concat "Name cannot be converted to DOS 8.3 format: " [token.quote $name]]}
	set r [string.upper [string.left [list.at $parts 0] 8]]
	if {= $nparts 2} then {set r [string.concat $r "." [string.upper [string.left [list.at $parts 1] 3]]]}
	pass $r
}

proc dos.make83.path {$path} {
	arg.must.quoted path
	set names [string.split $path "/"]
	set result {}
	foreach name $names {set result [list.add $result [dos.make83 $name]]}
	string.join $result "/"
}

proc dos.make83.paths {$paths} {
	arg.must.list paths
	set map %{}
	foreach path $paths {set map [dict.set $map $path [dos.make83 $path]]}
	set dups [dict.find.duplicate.values $map]
	if {> [dict.size $dups] 0} then {
		error [string.concat "DOS 8.3 paths are not unique: " $dups]
	}
	pass $map
}

proc dos.version {} {
	set r [dos.int86 [hex 21] [dict ah [hex 30]]]
	set major [dict.get $r al]
	set minor [dict.get $r ah]
	string.concat $major "." $minor
}

proc dos.key.installed {} {
	set r [dos.int86 [hex 2f] [dict ax [hex 4800]]]
	not [= 0 [dict.get $r al]]
}

proc dos.key.read {} {
	set mem.buf [dos.mem.alloc 130]
	set mem.seg [channel.control $mem.buf {segment}]
	channel.control $mem.buf [list byte.set 0 [hex 80]]
	set result [dos.int86 [hex 2f] [dict ax [hex 4810] ds $mem.seg]]
	if {not [= [dict.get $result ax] 0]} then {
		channel.close $mem.buf
		error "dos.key.read: DOSKEY call (INT 0x2F,AX=0x4810) failed"
	}
	set bytes [channel.control $mem.buf {byte.get 1}]
	if {= 0 $bytes} then {
		channel.close $mem.buf
		puts ""
		return ""
	}
	channel.control $mem.buf [list byte.set 0 [hex 20]]
	channel.control $mem.buf [list byte.set 1 [hex 20]]
	channel.control $mem.buf [list byte.set [+ $bytes 2] 0]
	set read [channel.read $mem.buf 144]
	channel.close $mem.buf
	puts ""
	set r [string.skip $read 2]
	if {= $r [string.chr 26]} then {return [null]}
	pass $r
}

proc dos.vesa.info.raw {} {
	set mem.buf [dos.mem.alloc 272]
	set mem.seg [channel.control $mem.buf {segment}]
	set r [dos.int86 [hex 10] [dict ax [hex 4f00] es $mem.seg]]
	if {not [= [dict.get $r ax] [hex 4f]]} then {
		channel.close $mem.buf
		return [null]
	}
	set r [channel.read.hex $mem.buf 256]
	channel.close $mem.buf
	if {not [= [hex.sub $r 0 4] [hex.encode "VESA"]]} then {return [null]}
	return $r
}

proc dos.vesa.info {} {
	set r [dos.vesa.info.raw]
	if {is.null $r} then {return [null]}
	set h %{}
	set minor [from.radix.i32 [hex.sub $r 4 1] 16]
	set major [from.radix.i32 [hex.sub $r 5 1] 16]
	set version [string.concat $major "." $minor]
	set h [dict.set $h version $version]
	set oem.fp [hex.reverse [hex.sub $r 6 4]]
	set oem.fpseg [from.radix.i32 [hex.sub $oem.fp 0 2] 16]
	set oem.fpoff [from.radix.i32 [hex.sub $oem.fp 2 2] 16]
	set oem.string [dos.mem.peek.asciiz $oem.fpseg $oem.fpoff]
	set h [dict.set $h oem.string $oem.string]
	set abilities [hex.reverse [hex.sub $r 10 4]]
	set h [dict.set $h abilities $abilities]
	set modes.fp [hex.reverse [hex.sub $r 14 4]]
	set modes.fpseg [from.radix.i32 [hex.sub $modes.fp 0 2] 16]
	set modes.fpoff [from.radix.i32 [hex.sub $modes.fp 2 2] 16]
	set h [dict.set $h modes [dos.vesa.modelist $modes.fpseg $modes.fpoff]]
	pass $h
}

proc dos.vesa.mode.get {} {
	set r [dos.int86 [int 10] [dict ax [hex 4f03]]]
	if {not [= [dict.get $r ax] [hex 4f]]} then {return [null]}
	dict.get $r bx
}

proc dos.vesa.modelist {$seg $off} {
	set r {}
	loop {
		set mode [dos.mem.peek16 $seg $off]
		if {= $mode "FFFF"} then {return $r}
		set r [list.add $r $mode]
		set off [+ 2 $off]
	}
}

proc dos.snail.init {} {
	if {dos.key.installed} then {
		repl.read.script.set {dos.key.read}
	}
}

proc dos.bda.get.byte {$off} {
	dos.mem.peek [hex 40] $off
}

proc dos.bda.screen.columns {} {dos.bda.get.byte [hex 4A]}
proc dos.bda.screen.rows {} {dos.bda.get.byte [hex 84]}

proc dos.vmode.get {} {
	set vesa.mode [dos.vesa.mode.get]
	if {not.null $vesa.mode} then {return $vesa.mode}
	set r [dos.int86 [hex 10] [dict ah [hex 0f]]]
	dict videoMode [dict.get $r al] columnsPerLine [dict.get $r ah] activePage [dict.get $r bh]
}

proc dos.vmode.set {$mode} {
	arg.must.int mode
	dos.int86 [hex 10] [dict ah 0 al $mode]
	set curMode [dict.get [dos.vmode.get] videoMode]
	if {not [= $mode $curMode]} then {
		error [string.concat "set video mode " $mode " failed; still in mode " $curMode]
	}
	null
}

proc dos.vmode.enter {$mode} {
	arg.must.int mode
	set curMode [dict.get [dos.vmode.get] videoMode]
	if {= $mode $curMode} then {return [null]}
	dos.vmode.set $mode
}

proc dos.vmode.save {$code} {
	set mode [dict.get [dos.vmode.get] videoMode]
	cleanup {eval.up 1 $code} {dos.vmode.enter $mode}
}

proc dos.vmode.all {} {dos.vmode.save {
	set r {}
	set i 0
	while {< $i 128} {
		catch {
			dos.vmode.set $i
			set r [list.add $r $i]
		} e {null}
		set i [+ 1 $i]
	}
	pass $r
}}

proc dos.vpage.set {$page} {
	arg.must.int page
	dos.int86 [hex 10] [dict ah 5 al $page]
	set curPage [dict.get [dos.vmode.get] activePage]
	if {not [= $page $curPage]} then {
		error [string.concat "set video page " $page " failed; still in page " $curPage]
	}
	null
}

proc dos.vpage.enter {$page} {
	arg.must.int page
	set curPage [dict.get [dos.vmode.get] activePage]
	if {= $page $curPage} then {return [null]}
	dos.vpage.set $page
}

proc dos.vpage.get {} {dict.get [dos.vmode.get] activePage}

proc dos.vpage.cursor.get {$page} {
	arg.must.int page
	set regs [dos.int86 [hex 10] [dict ah 3 bh $page]]
	dict page $page startScanLine [dict.get $regs ch] endScanLine [dict.get $regs cl] row [dict.get $regs dh] column [dict.get $regs dl]
}

proc dos.cursor.get {} {dos.vpage.cursor.get [dos.vpage.get]}
proc dos.vpage.cursor.set {$page $row $col} {
	arg.must.int page
	arg.must.int row
	arg.must.int col
	dos.int86 [hex 10] [dict bh $page dh $row dl $col ah 2]
	null
}
proc dos.cursor.set {$row $col} {dos.vpage.cursor.set [dos.vpage.get] $row $col}
proc dos.cursor.home {} {dos.cursor.set 0 0}

proc dos.cls {} {
	set regs %{}
	set regs [dict.set $regs dh [dos.bda.screen.rows]]
	set regs [dict.set $regs dl [dos.bda.screen.columns]]
	set regs [dict.set $regs cx 0]
	set regs [dict.set $regs bh 7]
	set regs [dict.set $regs al 0]
	set regs [dict.set $regs ah 6]
	dos.int86 [hex 10] $regs
	null
}
proc dos.cls.home {} {
	dos.cls
	dos.cursor.home
}
proc dos.pause.key {} {
	dos.int86 [hex 21] [dict ax [hex 0c07]]
	dos.int86 [hex 21] [dict ax [hex 0c00]]
	null
}
proc dos.pause {} {
	puts.nonewline "Press any key to continue..."
	dos.pause.key
	puts ""
}

proc dos.mem.peek16 {$seg $off} {
	arg.must.int seg
	arg.must.int off
	set r ""
	set r [string.concat $r [hex.byte [dos.mem.peek $seg $off]]]
	set r [string.concat $r [hex.byte [dos.mem.peek $seg [+ 1 $off]]]]
	set r [hex.reverse $r]
	pass $r
}

proc dos.mem.peek.asciiz {$seg $off} {
	arg.must.int seg
	arg.must.int off
	set r ""
	loop {
		set b [dos.mem.peek $seg $off]
		if {= $b 0} then {break}
		set r [string.concat $r [hex.byte $b]]
		set off [+ 1 $off]
	}
	hex.decode $r
}

proc dos.vesa.modeinfo.raw {$mode} {
	arg.must.int mode
	if {or {< $mode 0} {> $mode [hex FFFF]}} then {error "$mode argument out of valid range"}
	set mem.buf [dos.mem.alloc 272]
	set mem.seg [channel.control $mem.buf {segment}]
	set r [dos.int86 [hex 10] [dict ax [hex 4f01] es $mem.seg cx $mode]]
	if {not [= [dict.get $r ax] [hex 4f]]} then {
		channel.close $mem.buf
		return [null]
	}
	set r [channel.read.hex $mem.buf 256]
	channel.close $mem.buf
	return $r
}
