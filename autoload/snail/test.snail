test.case snail.test.t1000 {test.assert.eq 2 {+ 1 1}}
test.case snail.test.t1001 {test.assert.error {file.run [string.concat [rand.hex 8] ".tmp"] }}
test.case snail.test.t1002 {test.assert.error {file.read [string.concat [rand.hex 8] ".tmp"] }}
test.case snail.test.t1003 {test.assert.error {error "intentionally induced"}}
test.case snail.test.t1004 {test.assert {string.is.blank ""}}
test.case snail.test.t1005 {test.assert {string.is.blank " "}}
test.case snail.test.t1006 {test.assert {string.is.blank "\t"}}
test.case snail.test.t1007 {test.assert {string.is.blank "\n"}}
test.case snail.test.t1008 {test.assert.not {string.is.blank "x"}}
test.case snail.test.t1009 {test.assert.not {string.is.blank " x"}}
test.case snail.test.t1010 {test.assert.not {string.is.blank "x "}}
test.case snail.test.t1011 {test.assert.not {string.is.blank "two words"}}
test.case snail.test.t1012 {test.assert.error {string.is.blank {}}}
test.case snail.test.t1013 {test.assert.error {string.is.digits {}}}
test.case snail.test.t1014 {test.assert.not {string.is.digits ""}}
test.case snail.test.t1015 {test.assert {string.is.digits "0"}}
test.case snail.test.t1016 {test.assert {string.is.digits "9"}}
test.case snail.test.t1017 {test.assert {string.is.digits "123456789"}}
test.case snail.test.t1018 {test.assert.not {string.is.digits "a"}}
test.case snail.test.t1019 {test.assert.not {string.is.digits "9a"}}
test.case snail.test.t1020 {test.assert.not {string.is.digits "A9"}}
test.case snail.test.t1021 {test.assert {is.bool t}}
test.case snail.test.t1022 {test.assert {is.bool f}}
test.case snail.test.t1023 {test.assert.not {is.bool ""}}
test.case snail.test.t1024 {test.assert.not {is.bool [null]}}
test.case snail.test.t1025 {test.assert.not {is.bool "t"}}
test.case snail.test.t1026 {test.assert.not {is.bool "f"}}
test.case snail.test.t1027 {test.assert {is.bool T}}
test.case snail.test.t1028 {test.assert {is.bool F}}
test.case snail.test.t1029 {test.assert.not {is.bool true}}
test.case snail.test.t1030 {test.assert.not {is.bool false}}
test.case snail.test.t1031 {test.assert.not {is.bool "t"}}
test.case snail.test.t1032 {test.assert.not {is.bool "f"}}
test.case snail.test.t1033 {test.assert.not {is.bool {}}}
test.case snail.test.t1034 {test.assert.not {is.bool %{}}}
test.case snail.test.t1035 {test.assert.null {channel.write stdout "Hello World!\n"}}
test.case snail.test.t1036 {test.assert {if {pass f} then {pass f} elseif {pass f} then {pass f} elseif {pass t} then {pass t} else {pass f}}}
test.case snail.test.t1037 {test.assert {is.true t}}
test.case snail.test.t1038 {test.assert.not {is.true f}}
test.case snail.test.t1039 {test.assert.not {is.false t}}
test.case snail.test.t1040 {test.assert {is.false f}}
test.case snail.test.t1041 {test.assert.not {is.int foo}}
test.case snail.test.t1042 {test.assert {is.int 0}}
test.case snail.test.t1043 {test.assert {is.int -99}}
test.case snail.test.t1044 {test.assert.not {is.int "0"}}
test.case snail.test.t1045 {test.assert.not {is.int "-99"}}
test.case snail.test.t1046 {test.assert {is.int 123456}}
test.case snail.test.t1047 {test.assert.eq 0 {string.length ""}}
test.case snail.test.t1048 {test.assert.eq 1 {string.length "A"}}
test.case snail.test.t1049 {test.assert.eq 3 {string.length "ABC"}}
test.case snail.test.t1050 {test.assert.eq 0 {string.cmp "" ""}}
test.case snail.test.t1051 {test.assert.eq 0 {string.cmp "A" "A"}}
test.case snail.test.t1052 {test.assert.eq -1 {string.cmp "A" "B"}}
test.case snail.test.t1053 {test.assert.eq 1 {string.cmp "B" "A"}}
test.case snail.test.t1054 {test.assert.eq -1 {string.cmp "ABC0" "ABC1"}}
test.case snail.test.t1055 {test.assert.eq 1 {string.cmp "ABC1" "ABC0"}}
test.case snail.test.t1056 {test.assert.eq -1 {string.cmp "A" "a"}}
test.case snail.test.t1057 {test.assert.eq 1 {string.cmp "a" "A"}}
test.case snail.test.t1058 {test.assert.eq 0 {string.casecmp "A" "a"}}
test.case snail.test.t1059 {test.assert.eq -1 {string.casecmp "a" "B"}}
test.case snail.test.t1060 {test.assert.eq 1 {string.casecmp "B" "a"}}
test.case snail.test.t1061 {test.assert.error {+ {} {}}}
test.case snail.test.t1062 {test.assert.error {- {} {}}}
test.case snail.test.t1063 {test.assert.eq 4 {* 2 2}}
test.case snail.test.t1064 {test.assert.error {* 10 "10"}}
test.case snail.test.t1065 {test.assert.eq 5 {/ 10 2}}
test.case snail.test.t1066 {test.assert.error {/ 10 0}}
test.case snail.test.t1067 {test.assert.error {/ "10" "2"}}
test.case snail.test.t1068 {test.assert {< -5 5}}
test.case snail.test.t1069 {test.assert.not {< 5 -5}}
test.case snail.test.t1070 {test.assert {> 5 -5}}
test.case snail.test.t1071 {test.assert.not {> -5 5}}
test.case snail.test.t1072 {test.assert.not {> 1 2}}
test.case snail.test.t1073 {test.assert {> 2 1}}
test.case snail.test.t1074 {test.assert {<= -5 0}}
test.case snail.test.t1075 {test.assert {>= 0 0}}
test.case snail.test.t1076 {test.assert.not {> 0 0}}
test.case snail.test.t1077 {test.assert.not {< 0 0}}
test.case snail.test.t1078 {test.assert {is.int [info.cmds.count]}}
test.case snail.test.t1079 {test.assert.eq 0 {list.length {}}}
test.case snail.test.t1080 {test.assert.eq 3 {list.length {a b c}}}
test.case snail.test.t1081 {test.assert.eq {1 2 3} {list.sort {3 1 2}}}
test.case snail.test.t1082 {test.assert.error {list.sort ""}}
test.case snail.test.t1083 {test.assert.eq 4 {list.at {1 9 8 4} 3}}
test.case snail.test.t1084 {test.assert.eq 9 {list.at {1 9 8 4} 1}}
test.case snail.test.t1085 {test.assert.error {list.at {} 0}}
test.case snail.test.t1086 {test.assert.error {list.at "" 0}}
test.case snail.test.t1087 {test.assert.error {set.up -1 x 0}}
test.case snail.test.t1088 {test.assert.error {var.get.up -1 x}}
test.case snail.test.t1089 {test.assert.eq L {token.classify [info.vars]}}
test.case snail.test.t1090 {test.assert.null {unsupported.parse.dump "{}"}}
test.case snail.test.t1091 {test.assert.eq Q {token.classify [repl.prompt.get]}}
test.case snail.test.t1092 {test.assert.error {eval ""}}
test.case snail.test.t1093 {test.assert.error {proc "" {} {}}}
test.case snail.test.t1094 {test.assert.error {if}}
test.case snail.test.t1095 {test.assert.error {if t then f}}
test.case snail.test.t1096 {test.assert.error {if {error "intentionally induced"} then {pass t}}}
test.case snail.test.t1097 {test.assert {is.int [time.now]}}
test.case snail.test.t1098 {test.assert {> [time.now] 0}}
test.case snail.test.t1099 {test.assert {is.int [time.startup]}}
test.case snail.test.t1100 {test.assert {> [time.startup] 0}}
test.case snail.test.t1101 {test.assert {token.is.quoted [file.read [module.find.path snail.test]]}}
test.case snail.test.t1102 {test.assert.eq {1 2 3 4} {list.add {1 2 3} 4}}
test.case snail.test.t1103 {test.assert.error {list.add "{1 2 3}" 4}}
test.case snail.test.t1104 {test.assert.eq {1 2 3 4} {list.concat {1} {2} {3} {4}}}
test.case snail.test.t1105 {test.assert.eq "x{}" {string.concat "x" {}}}
test.case snail.test.t1106 {test.assert {is.int [frame.count]}}
test.case snail.test.t1107 {test.assert {> [frame.count] 0}}
test.case snail.test.t1108 {test.assert {and}}
test.case snail.test.t1109 {test.assert.not {or}}
test.case snail.test.t1110 {test.assert {or {pass t} {error "shouldn't run"}}}
test.case snail.test.t1111 {test.assert.not {and {pass f} {error "shouldn't run"}}}
test.case snail.test.t1112 {test.assert {and {pass t} {pass t}}}
test.case snail.test.t1113 {test.assert.not {and {pass t} {pass f}}}
test.case snail.test.t1114 {test.assert {or {pass f} {pass t}}}
test.case snail.test.t1115 {test.assert {and {pass t}}}
test.case snail.test.t1116 {test.assert.not {and {pass f}}}
test.case snail.test.t1117 {test.assert {or {pass t}}}
test.case snail.test.t1118 {test.assert.not {or {pass f}}}
test.case snail.test.t1119 {test.assert.error {file.write "." ""}}
test.case snail.test.t1120 {test.assert {string.ends.with "abc" "c"}}
test.case snail.test.t1121 {test.assert {string.ends.with "" ""}}
test.case snail.test.t1122 {test.assert {string.ends.with "abc" ""}}
test.case snail.test.t1123 {test.assert {string.ends.with "hello" "lo"}}
test.case snail.test.t1124 {test.assert {string.starts.with "hello" "hell"}}
test.case snail.test.t1125 {test.assert.not {string.starts.with "abc" "b"}}
test.case snail.test.t1126 {test.assert.not {string.ends.with "abc" "d"}}
test.case snail.test.t1127 {test.assert.eq "" {string.trim ""}}
test.case snail.test.t1128 {test.assert.eq "xyz" {string.trim " xyz\t\t"}}
test.case snail.test.t1129 {test.assert.eq "xyz" {string.trim "xyz"}}
test.case snail.test.t1130 {test.assert.eq "A" {string.chr 65}}
test.case snail.test.t1131 {test.assert.eq 65 {string.char.at "APPLE" 0}}
test.case snail.test.t1132 {test.assert.eq 76 {string.char.at "APPLE" 3}}
test.case snail.test.t1133 {test.assert.eq "hello" {string.lower "Hello"}}
test.case snail.test.t1134 {test.assert.eq "HELLO" {string.upper "Hello"}}
test.case snail.test.t1135 {test.assert {token.is.dict [info.channels]}}
test.case snail.test.t1136 {test.assert {dict.has [info.channels] stdin}}
test.case snail.test.t1137 {test.assert {dict.has [info.channels] stdout}}
test.case snail.test.t1138 {test.assert {dict.has [info.channels] stderr}}
test.case snail.test.t1139 {test.assert {token.is.list [info.channel.drivers]}}
test.case snail.test.t1140 {test.assert.eq "BarBaz" {string.skip "FooBarBaz" 3}}
test.case snail.test.t1141 {test.assert.eq "Foo" {string.left "FooBarBaz" 3}}
test.case snail.test.t1142 {test.assert {token.is.list [info.globals]}}
test.case snail.test.t1143 {test.assert {> [list.length [info.channel.drivers]] 0}}
test.case snail.test.t1144 {test.assert.eq proc {dict.get [info.about.cmd proc] name}}
test.case snail.test.t1145 {test.assert.eq dir {dict.get [file.stat "."] type}}
test.case snail.test.t1146 {test.assert.eq 4 {dict.size [dict.set.all %{x 1 y 2 z 3} %{x 99 a 15 y 6}]}}
test.case snail.test.t1147 {test.assert.eq 99 {dict.get [dict.set.all %{x 1 y 2 z 3} %{x 99 a 15 y 6}] x}}
test.case snail.test.t1148 {test.assert {dict.has %{x 1} x}}
test.case snail.test.t1149 {test.assert.not {dict.has %{x 1} y}}
test.case snail.test.t1150 {test.assert.eq 0 {dict.size %{}}}
test.case snail.test.t1151 {test.assert.eq 1 {dict.size %{x 1}}}
test.case snail.test.t1152 {test.assert.eq {x y z} {list.sort [dict.keys %{x 1 y 2 z 3}]}}
test.case snail.test.t1153 {test.assert.eq %{x 1} {dict x 1}}
test.case snail.test.t1154 {test.assert.error {dict x 1 y}}
test.case snail.test.t1155 {test.assert.eq %{x 99} {dict x 1 x 99}}
test.case snail.test.t1156 {test.assert {token.is.list [frame.cmds]}}
test.case snail.test.t1157 {test.assert {> [list.length [frame.cmds]] 0}}
test.case snail.test.t1158 {test.assert.eq 0 {nvl 0}}
test.case snail.test.t1159 {test.assert.null {nvl [null]}}
test.case snail.test.t1160 {test.assert.eq 99 {nvl [null] 99}}
test.case snail.test.t1161 {test.assert.eq 99 {nvl [null] [null] 99 [null]}}
test.case snail.test.t1162 {test.assert.null {nvl [null] [null] [null] [null]}}
test.case snail.test.t1163 {test.assert.error {list.length ""}}
test.case snail.test.t1164 {test.assert.null {puts.nonewline "This should print a single line\n"}}
test.case snail.test.t1165 {test.assert.error {and {error "intentional error"}}}
test.case snail.test.t1166 {test.assert.error {or {error "intentional error"}}}
test.case snail.test.t1167 {test.assert.error {and {pass 0}}}
test.case snail.test.t1168 {test.assert.error {or {pass 0}}}
test.case snail.test.t1169 {test.assert.eq "1 2 3" {token.list.body {1 2 3}}}
test.case snail.test.t1170 {test.assert.not {string.ends.with "X" "XYZ"}}
test.case snail.test.t1171 {test.assert.null {string.char.at "" 0}}
test.case snail.test.t1172 {test.assert {token.is.symbol [frame.cmd.up 0]}}
test.case snail.test.t1173 {test.assert.error {frame.cmd.up -1}}
test.case snail.test.t1174 {test.assert.eq "" {string.left "x" -1}}
test.case snail.test.t1175 {test.assert.eq "x" {string.left "x" 30}}
test.case snail.test.t1176 {test.assert.null {string.find.rev "abc" "d"}}
test.case snail.test.t1177 {test.assert.eq 2 {string.find.rev "bob" "b"}}
test.case snail.test.t1178 {test.assert.eq 0 {string.find.at "bob" "b" 0}}
test.case snail.test.t1179 {test.assert.eq 2 {string.find.at "bob" "b" 1}}
test.case snail.test.t1180 {test.assert.eq 0 {string.find.at "cowdogcow" "cow" 0}}
test.case snail.test.t1181 {test.assert.eq 6 {string.find.at "cowdogcow" "cow" 1}}
test.case snail.test.t1182 {test.assert {dict.has [info.about.cmd help] script}}
test.case snail.test.t1183 {test.assert.error {list.concat {} ""}}
test.case snail.test.t1184 {test.assert.error {proc}}
test.case snail.test.t1185 {test.assert.error {string.length {}}}
test.case snail.test.t1186 {test.assert.error {string.cmp {} ""}}
test.case snail.test.t1187 {test.assert.error {string.cmp "" {}}}
test.case snail.test.t1188 {test.assert.error {string.casecmp "" {}}}
test.case snail.test.t1189 {test.assert.error {string.casecmp "" {}}}
test.case snail.test.t1190 {test.assert.error {+}}
test.case snail.test.t1191 {test.assert.error {-}}
test.case snail.test.t1192 {test.assert.eq -10 {- 10}}
test.case snail.test.t1193 {test.assert.eq 10 {- -10}}
test.case snail.test.t1194 {test.assert.eq 7 {- 10 3}}
test.case snail.test.t1195 {test.assert.eq 3 {- 10 3 4}}
test.case snail.test.t1196 {test.assert.error {*}}
test.case snail.test.t1197 {test.assert.error {/}}
test.case snail.test.t1198 {test.assert.eq 4 {/ 8 2}}
test.case snail.test.t1199 {test.assert.eq 2 {/ 8 2 2}}
test.case snail.test.t1200 {test.assert.eq 7 {/ 210 2 3 5}}
test.case snail.test.t1201 {test.assert.error {< "0" 0}}
test.case snail.test.t1202 {test.assert.error {< 0 "0"}}
test.case snail.test.t1203 {test.assert.error {> 0 "0"}}
test.case snail.test.t1204 {test.assert.error {> "0" 0}}
test.case snail.test.t1205 {test.assert.error {<= 0 "0"}}
test.case snail.test.t1206 {test.assert.error {<= "0" 0}}
test.case snail.test.t1207 {test.assert.error {>= 0 "0"}}
test.case snail.test.t1208 {test.assert.error {>= "0" 0}}
test.case snail.test.t1209 {test.assert.null {puts 0}}
test.case snail.test.t1210 {
	set x123 456
	test.assert.eq 456 {var.get x123}
	test.assert {var.has x123}
}
test.case snail.test.t1211 {test.assert.error {string.casecmp 0 "0"}}
test.case snail.test.t1212 {test.assert.null {loop {break}}}
test.case snail.test.t1213 {
	test.assert.eq {20 42} {
		set i 0
		set r {}
		loop {
			set i [+ $i 1]
			if {< $i 10} then {continue}
			set i [* $i 2]
			if {> $i 50} then {break}
			set r [list.add $r $i]
		}
		pass $r
	}
}
test.case snail.test.t1214 {
	set orig [repl.prompt.get]
	set new "TEST REPL PROMPT> "
	test.assert.null {repl.prompt.set $new}
	test.assert.eq $new {repl.prompt.get}
	test.assert.null {repl.prompt.set $orig}
	test.assert.eq $orig {repl.prompt.get}
}
test.case snail.test.t1215 {test.assert.error {catch "" e {}}}
test.case snail.test.t1216 {test.assert.error {catch {} "" {}}}
test.case snail.test.t1217 {test.assert.error {catch {} e ""}}
test.case snail.test.t1218 {test.assert.error {file.read {}}}
test.case snail.test.t1219 {test.assert.error {file.run {}}}
test.case snail.test.t1220 {test.assert.error {list.concat "" {}}}
test.case snail.test.t1221 {test.assert.error {list.concat}}
test.case snail.test.t1222 {test.assert.error {string.concat}}
test.case snail.test.t1223 {test.assert.error {string.starts.with "A" A}}
test.case snail.test.t1224 {test.assert.error {string.starts.with A "A"}}
test.case snail.test.t1225 {test.assert.null {while {pass t} {break}}}
test.case snail.test.t1226 {test.assert.null {while {pass f} {continue}}}
test.case snail.test.t1227 {test.assert.error {dict.size {}}}
test.case snail.test.t1228 {test.assert.error {list.length %{}}}
test.case snail.test.t1229 {test.assert.eq {} {dict.keys %{}}}
test.case snail.test.t1230 {test.assert.error {dict.keys {}}}
test.case snail.test.t1231 {test.assert.error {global.set "test" 1}}
test.case snail.test.t1232 {test.assert.error {global.get "test"}}
test.case snail.test.t1233 {test.assert.error {string.find {} ""}}
test.case snail.test.t1234 {test.assert.error {string.find "" {}}}
test.case snail.test.t1235 {test.assert.error {loop "BAD"}}
test.case snail.test.t1236 {test.assert.error {loop {error "intentional"}}}
test.case snail.test.t1237 {test.assert.error {if {pass t} {pass t}}}
test.case snail.test.t1238 {test.assert.error {if {} {} {}}}
test.case snail.test.t1239 {test.assert.not {proc.exists [token.unquote [string.concat "nonexistent.proc." [rand.hex 8]]]}}
test.case snail.test.t1240 {test.assert.eq 64 {string.length [rand.hex 32]}}
test.case snail.test.t1241 {test.assert {is.int [rand.u32]}}
test.case snail.test.t1242 {
	set name [token.unquote [string.concat "V" [rand.hex 8]]]
	set value [rand.hex 8]
	test.assert.not {var.has $name}
	set $name $value
	test.assert {var.has $name}
	test.assert.eq $value {var.get $name}
	var.del $name
	test.assert.not {var.has $name}
	test.assert.error {var.get $name}
}
test.case snail.test.t1243 {test.assert.error {proc.delete proc.delete}}
test.case snail.test.t1244 {
	set name [token.unquote [string.concat "V" [rand.hex 8]]]
	set value [rand.hex 8]
	test.assert.not {proc.exists $name}
	test.assert.error [list $name]
	test.assert.null {proc $name {} [list pass $value]}
	test.assert {proc.exists $name}
	test.assert.eq $value [list $name]
	test.assert.null {proc.delete $name}
	test.assert.not {proc.exists $name}
	test.assert.error [list $name]
}
test.case snail.test.t1245 {test.assert.error {proc.delete [token.unquote [string.concat "proc.nonexistent." [rand.hex 8]]]}}
test.case snail.test.t1246 {
	puts.nonewline "This should "
	puts.nonewline "all be "
	puts.nonewline "on one line "
	puts.nonewline 1234567890
	puts.nonewline "\n"
}
test.case snail.test.t1247 {test.assert.eq 0 {list.find {a b c} a}}
test.case snail.test.t1248 {test.assert.eq 1 {list.find {a b c} b}}
test.case snail.test.t1249 {test.assert.eq 2 {list.find {a b c} c}}
test.case snail.test.t1250 {test.assert.eq 2 {list.find {a b c a b c} c}}
test.case snail.test.t1251 {test.assert.null {list.find {a b c} x}}
test.case snail.test.t1252 {test.assert.null {list.find {a b c} [null]}}
test.case snail.test.t1253 {test.assert.null {list.find {} x}}
test.case snail.test.t1254 {test.assert {list.contains {a b c} a}}
test.case snail.test.t1255 {test.assert.not {list.contains {} a}}
test.case snail.test.t1256 {test.assert {list.contains {a b c} c}}
test.case snail.test.t1257 {test.assert.error {list.find "x" x}}
test.case snail.test.t1258 {test.assert.error {list.find "x" "x"}}
test.case snail.test.t1259 {test.assert.eq "0" {to.hex 0}}
test.case snail.test.t1260 {test.assert.eq "FE" {to.hex 254}}
test.case snail.test.t1261 {test.assert.eq "A" {to.hex 10}}
test.case snail.test.t1262 {test.assert.eq "499602D2" {to.hex 1234567890}}
test.case snail.test.t1263 {test.assert.error {to.hex "0"}}
test.case snail.test.t1264 {test.assert.error {proc.delete {}}}
test.case snail.test.t1265 {test.assert.eq "" {rand.hex 0}}
test.case snail.test.t1266 {test.assert.error {rand.hex -1}}
test.case snail.test.t1267 {test.assert.error {or t t}}
test.case snail.test.t1268 {test.assert.error {and t t}}
test.case snail.test.t1269 {test.assert.error {rand.hex "0"}}
test.case snail.test.t1270 {test.assert.error {string.trim {}}}
test.case snail.test.t1271 {test.assert.eq "" {string.chr 0}}
test.case snail.test.t1272 {test.assert.error {string.chr "65"}}
test.case snail.test.t1273 {test.assert.error {string.lower {}}}
test.case snail.test.t1274 {test.assert.error {string.upper {}}}
test.case snail.test.t1275 {test.assert.eq "" {string.skip "A" 99}}
test.case snail.test.t1276 {test.assert.eq "ELLO" {string.sub "HELLO" 1 99}}
test.case snail.test.t1277 {test.assert.eq "" {string.sub "HELLO" 99 1}}
test.case snail.test.t1278 {test.assert.error {string.left hello 1}}
test.case snail.test.t1279 {test.assert.error {string.left "hello" "1"}}
test.case snail.test.t1280 {test.assert.error {string.find.rev foobarfoo "o"}}
test.case snail.test.t1281 {test.assert.error {string.find.rev "foobarfoo" o}}
test.case snail.test.t1282 {test.assert.error {string.replace foobarbaz "bar" "quux"}}
test.case snail.test.t1283 {test.assert.error {string.replace "foobarbaz" bar "quux"}}
test.case snail.test.t1284 {test.assert.error {string.replace "foobarbaz" "bar" quux}}
test.case snail.test.t1285 {test.assert.eq "fooquuxbaz" {string.replace "foobarbaz" "bar" "quux"}}
test.case snail.test.t1286 {test.assert.null {global.get [token.unquote [string.concat "nonexistent.global." [rand.hex 8]]]}}
test.case snail.test.t1287 {test.assert.null {info.about.cmd [token.unquote [string.concat "nonexistent.proc." [rand.hex 8]]]}}
test.case snail.test.t1288 {test.assert.error {info.about.cmd {}}}
test.case snail.test.t1289 {test.assert.error {file.stat {}}}
test.case snail.test.t1290 {test.assert.error {dict.set.all %{a 1} {a 2}}}
test.case snail.test.t1291 {test.assert.error {dict.set.all {a 1} %{a 2}}}
test.case snail.test.t1292 {test.assert.error {nvl}}
test.case snail.test.t1293 {test.assert.error {foreach {} {} {}}}
test.case snail.test.t1294 {test.assert.error {foreach foo foo foo}}
test.case snail.test.t1295 {test.assert.error {foreach foo {} foo}}
test.case snail.test.t1296 {test.assert.error {if {pass t} then then}}
test.case snail.test.t1297 {test.assert.error {if {pass t} then {pass t} elseif}}
test.case snail.test.t1298 {test.assert.error {if {pass t} then {pass t} elseif {pass t}}}
test.case snail.test.t1299 {test.assert.error {if {pass t} then {pass t} elseif {pass t} then}}
test.case snail.test.t1300 {test.assert.error {if {pass t} then {pass t} elseif {pass t} then {pass t} else}}
test.case snail.test.t1301 {test.assert.error {if {pass "t"} then {pass "t"}}}
test.case snail.test.t1302 {
	set temp.proc.name [token.unquote [string.concat "temp.proc." [rand.hex 8]]]
	set temp.var.name [token.unquote [string.concat "temp.var." [rand.hex 8]]]
	set value [rand.hex 8]
	test.assert.null {proc $temp.proc.name {$k $v} {set.up 1 $k $v}}
	test.assert.not {var.has $temp.var.name}
	test.assert.null [list $temp.proc.name $temp.var.name $value]
	test.assert {var.has $temp.var.name}
	test.assert.eq $value {var.get $temp.var.name}
	test.assert.null {proc.delete $temp.proc.name}
}
test.case snail.test.t1303 {
	test.assert.null {set temp.var1.name [token.unquote [string.concat "temp.var1." [rand.hex 8]]]}
	test.assert.null {set temp.var2.name [token.unquote [string.concat "temp.var2." [rand.hex 8]]]}
	test.assert.null {set value1 [rand.hex 8]}
	test.assert.null {set value2 [rand.hex 8]}

	test.assert.not {list.contains [info.vars] $temp.var1.name}
	test.assert.not {list.contains [info.vars] $temp.var2.name}
	test.assert.error {var.get $temp.var1.name}
	test.assert.error {var.get $temp.var2.name}

	test.assert.null {set $temp.var1.name $value1}
	test.assert {list.contains [info.vars] $temp.var1.name}
	test.assert.not {list.contains [info.vars] $temp.var2.name}
	test.assert.eq $value1 {var.get $temp.var1.name}
	test.assert.error {var.get $temp.var2.name}

	test.assert.null {set $temp.var2.name $value2}
	test.assert {list.contains [info.vars] $temp.var1.name}
	test.assert {list.contains [info.vars] $temp.var2.name}
	test.assert.eq $value1 {var.get $temp.var1.name}
	test.assert.eq $value2 {var.get $temp.var2.name}

	test.assert {var.del $temp.var1.name}
	test.assert.not {var.del $temp.var1.name}
	test.assert.not {list.contains [info.vars] $temp.var1.name}
	test.assert {list.contains [info.vars] $temp.var2.name}
	test.assert.error {var.get $temp.var1.name}
	test.assert.eq $value2 {var.get $temp.var2.name}

	test.assert {var.del $temp.var2.name}
	test.assert.not {var.del $temp.var2.name}
	test.assert.not {list.contains [info.vars] $temp.var1.name}
	test.assert.not {list.contains [info.vars] $temp.var2.name}
	test.assert.error {var.get $temp.var1.name}
	test.assert.error {var.get $temp.var2.name}
}
test.case snail.test.t1304 {test.assert {token.is.list {info.vars}}}
test.case snail.test.t1305 {test.assert.error {repl.prompt.set {}}}
test.case snail.test.t1306 {test.assert.error {set.up "0" x 33}}
test.case snail.test.t1307 {test.assert.error {var.get.up "0" x}}
test.case snail.test.t1308 {test.assert.error {proc x "" {}}}
test.case snail.test.t1309 {test.assert.error {proc x {} ""}}
test.case snail.test.t1310 {
	set temp.proc.name [token.unquote [string.concat "temp.proc." [rand.hex 8]]]
	test.assert.null {proc $temp.proc.name {} {}}
	test.assert.eq 0 {dict.get [info.about.cmd $temp.proc.name] arity}
	test.assert.eq {} {dict.get [info.about.cmd $temp.proc.name] args}
	test.assert.error {proc $temp.proc.name {} {}}
	test.assert.null {proc.delete $temp.proc.name}
	test.assert.null {info.about.cmd $temp.proc.name}
	test.assert.error {proc.delete $temp.proc.name}
}
test.case snail.test.t1311 {
	set temp.proc.name [token.unquote [string.concat "temp.proc." [rand.hex 8]]]
	test.assert.null {proc $temp.proc.name {& $x} {}}
	test.assert.eq -1 {dict.get [info.about.cmd $temp.proc.name] arity}
	test.assert.eq {& $x} {dict.get [info.about.cmd $temp.proc.name] args}
	test.assert.null {proc.delete $temp.proc.name}
	test.assert.null {info.about.cmd $temp.proc.name}
	test.assert.error {proc.delete $temp.proc.name}
}
test.case snail.test.t1312 {test.assert.error {string.ends.with a "a"}}
test.case snail.test.t1313 {test.assert.error {string.ends.with "a" a}}
test.case snail.test.t1314 {test.assert.error {string.char.at a 0}}
test.case snail.test.t1315 {test.assert.error {string.char.at "a" "0"}}
test.case snail.test.t1316 {test.assert.null {string.char.at "a" -1}}
test.case snail.test.t1317 {test.assert.error {channel.read {} 0}}
test.case snail.test.t1318 {test.assert.error {channel.read stdin "0"}}
test.case snail.test.t1319 {test.assert.error {channel.read stdin 0}}
test.case snail.test.t1320 {test.assert.error {channel.read [token.unquote [string.concat "nonexistent.channel." [rand.hex 8]]] 1}}
test.case snail.test.t1321 {test.assert.error {channel.write {} "foo"}}
test.case snail.test.t1322 {test.assert.error {channel.write stdout {}}}
test.case snail.test.t1323 {test.assert.error {channel.write [token.unquote [string.concat "nonexistent.channel." [rand.hex 8]]] "foo"}}
test.case snail.test.t1324 {
	set temp.proc.name [token.unquote [string.concat "temp.proc." [rand.hex 8]]]
	test.assert.null {proc $temp.proc.name {? $x} {}}
	test.assert.eq -1 {dict.get [info.about.cmd $temp.proc.name] arity}
	test.assert.eq {? $x} {dict.get [info.about.cmd $temp.proc.name] args}
	test.assert.null {proc.delete $temp.proc.name}
	test.assert.null {info.about.cmd $temp.proc.name}
	test.assert.error {proc.delete $temp.proc.name}
}
test.case snail.test.t1325 {test.assert.error {file.write "." {}}}
test.case snail.test.t1326 {test.assert.error {file.write {} ""}}
test.case snail.test.t1327 {test.assert.error {eval.up "0" {null}}}
test.case snail.test.t1328 {test.assert.error {eval.up 0 null}}
test.case snail.test.t1329 {test.assert.error {string.sub foobarbaz 3 3}}
test.case snail.test.t1330 {test.assert.error {string.sub "foobarbaz" "3" 3}}
test.case snail.test.t1331 {test.assert.error {string.sub "foobarbaz" 3 "3"}}
test.case snail.test.t1332 {test.assert.error {string.skip {} 1}}
test.case snail.test.t1333 {test.assert.error {string.skip "abc" "1"}}
test.case snail.test.t1334 {test.assert.error {string.find.at "" "" "0"}}
test.case snail.test.t1335 {test.assert.error {string.find.at "" {} 0}}
test.case snail.test.t1336 {test.assert.eq "(top)" {frame.cmd.up [- [frame.count] 1]}}
test.case snail.test.t1337 {test.assert.eq "" {string.sub "foobarbaz" -1 10}}
test.case snail.test.t1338 {test.assert.eq "" {string.skip "foobarbaz" -1}}
test.case snail.test.t1339 {test.assert.error {if {pass t} then {pass t} elseif t}}
test.case snail.test.t1340 {test.assert.error {if {pass t} then {pass t} elseif {pass t} else}}
test.case snail.test.t1341 {test.assert.error {if {pass t} then {pass t} elseif {pass t} then t}}
test.case snail.test.t1342 {test.assert.error {if {pass t} then {pass t} else t}}
test.case snail.test.t1343 {test.assert.error {if {pass t} then {pass t} else {pass t} else}}
test.case snail.test.t1344 {test.assert.error {if {pass t} then {pass t} then {pass t}}}
test.case snail.test.t1345 {test.assert.error {if {pass f} then {pass f} elseif {pass "t"} then {pass t}}}
test.case snail.test.t1346 {test.assert.error {if {pass f} then {pass f} elseif {error "intentionally induced"} then {pass f}}}
test.case snail.test.t1347 {test.assert.null {foreach x {1 2 3} {break}}}
test.case snail.test.t1348 {test.assert.null {foreach x {1 2 3} {continue}}}
test.case snail.test.t1349 {test.assert.error {list.at {a b c} "0"}}
test.case snail.test.t1350 {test.assert.error {while f {pass f}}}
test.case snail.test.t1351 {test.assert.error {while {pass f} f}}
test.case snail.test.t1352 {while {return [null]} {null}}
test.case snail.test.t1353 {
	set temp [string.concat [rand.hex 8] ".tmp"]
	test.assert.not {file.exists $temp}
	test.assert.error {file.read $temp}
	test.assert.error {file.delete $temp}
	set value1 [rand.hex 32]
	test.assert.null {file.write $temp $value1}
	test.assert {file.exists $temp}
	test.assert.eq $value1 {file.read $temp}
	set value2 [rand.hex 32]
	test.assert.null {file.write $temp $value2}
	test.assert {file.exists $temp}
	test.assert.eq $value2 {file.read $temp}
	test.assert.null {file.delete $temp}
	test.assert.not {file.exists $temp}
	test.assert.error {file.read $temp}
	test.assert.error {file.delete $temp}
}
test.case snail.test.t1354 {test.assert {not [= [rand.hex 256] [rand.hex 256]]}}
test.case snail.test.t1355 {test.assert.error {file.delete ""}}
test.case snail.test.t1356 {test.assert.error {file.delete {}}}
test.case snail.test.t1357 {test.assert.error {frame.cmd.up "0"}}
test.case snail.test.t1358 {test.assert.error {string.find.at foo "o" 2}}
test.case snail.test.t1359 {test.assert.null {string.find.at "foo" "o" -1}}
test.case snail.test.t1360 {test.assert.null {string.find.at "foo" "o" 99}}
test.case snail.test.t1361 {test.assert.null {string.find.at "foobarbaz" "foo" 1}}
test.case snail.test.t1362 {test.assert.eq 0 {string.find.at "foobarbazfoo" "foo" 0}}
test.case snail.test.t1363 {test.assert.eq 9 {string.find.at "foobarbazfoo" "foo" 1}}
test.case snail.test.t1364 {test.assert.error {list.at {a b c} -1}}
test.case snail.test.t1365 {
	set i 0
	while {pass t} {
		set i [+ 1 $i]
		if {< $i 10} then {continue}
		break
	}
	test.assert.eq 10 {pass $i}
}
test.case snail.test.t1366 {
	set temp [string.concat [rand.hex 8] ".tmp"]
	set value1 [rand.hex 256]
	set value2 [rand.hex 256]
	file.write $temp [token.list.body [list pass $value1]]
	test.assert.eq $value1 {file.run $temp}
	file.write $temp [token.list.body [list pass $value2]]
	test.assert.eq $value2 {file.run $temp}
	file.write $temp "{"
	test.assert.error {file.run $temp}
	file.delete $temp
	test.assert.not {file.exists $temp}
	test.assert.error {file.run $temp}
}
test.case snail.test.t1367 {test.assert.error {file.open [string.concat [rand.hex 8] ".tmp"] "r"}}
test.case snail.test.t1368 {test.assert.error {file.open [string.concat [rand.hex 8] ".tmp"] "rw"}}
test.case snail.test.t1369 {
	set name [string.concat [rand.hex 8] ".tmp"]
	set channel [file.open $name "w"]
	test.assert {token.is.symbol $channel}
	test.assert {dict.has [info.channels] $channel}
	test.assert.null {channel.close $channel}
	test.assert.not {dict.has [info.channels] $channel}
	test.assert.error {channel.close $channel}
	test.assert.null {file.delete $name}
	test.assert.error {file.delete $name}
}
test.case snail.test.t1370 {test.assert.error {channel.close stdout}}
test.case snail.test.t1371 {test.assert.error {channel.close stdin}}
test.case snail.test.t1372 {test.assert.error {channel.close stderr}}
test.case snail.test.t1373 {test.assert.error {channel.close [token.unquote [string.concat "nonexistent.channel." [rand.hex 16]]]}}
test.case snail.test.t1374 {
	set name [string.concat [rand.hex 8] ".tmp"]
	set value [rand.hex 128]
	test.assert.null {file.write $name $value}
	set channel [file.open $name "r"]
	test.assert.eq $value {channel.read $channel 256}
	test.assert.null {channel.read $channel 256}
	test.assert.null {channel.read $channel 256}
	test.assert.null {channel.close $channel}
	test.assert.error {channel.close $channel}
	test.assert.null {file.delete $name}
	test.assert.error {file.delete $name}
}
test.case snail.test.t1375 {test.assert.error {channel.close {}}}
test.case snail.test.t1376 {test.assert.error {file.open {} "r"}}
test.case snail.test.t1377 {test.assert.error {file.open "" {}}}
test.case snail.test.t1378 {test.assert.error {file.open "" "r"}}
test.case snail.test.t1380 {test.assert.eq 2 {math.shl.u32 1 1}}
test.case snail.test.t1381 {test.assert.eq 0 {math.shl.u32 0 10}}
test.case snail.test.t1382 {test.assert.eq 1024 {math.shl.u32 1 10}}
test.case snail.test.t1383 {test.assert.eq 40 {math.shl.u32 5 3}}
test.case snail.test.t1384 {test.assert.eq 37 {math.shl.u32 37 0}}
test.case snail.test.t1385 {test.assert.error {math.shl.u32 37 -1}}
test.case snail.test.t1386 {test.assert.error {math.shl.u32 -37 1}}
test.case snail.test.t1387 {test.assert.error {math.shl.u32 0 {}}}
test.case snail.test.t1388 {test.assert.error {math.shl.u32 {} 0}}
test.case snail.test.t1389 {test.assert.eq 31 {math.clz.u32 0}}
test.case snail.test.t1390 {test.assert.eq 31 {math.clz.u32 1}}
test.case snail.test.t1391 {test.assert.eq 15 {math.clz.u32 65536}}
test.case snail.test.t1392 {test.assert.eq 16 {math.clz.u32 65535}}
test.case snail.test.t1393 {test.assert.error {math.clz.u32 -1}}
test.case snail.test.t1394 {test.assert.error {math.clz.u32 "0"}}
test.case snail.test.t1395 {test.assert.error {rand.u32.uniform -1}}
test.case snail.test.t1396 {test.assert.error {rand.u32.uniform 0}}
test.case snail.test.t1397 {test.assert.error {rand.u32.uniform 1}}
test.case snail.test.t1398 {test.assert.error {rand.u32.uniform "2"}}
test.case snail.test.t1399 {test.assert {is.int [rand.u32.uniform 2]}}
test.case snail.test.t1400 {test.assert.null {repeat 50 {rand.u32.uniform 2049}}}
test.case snail.test.t1401 {test.assert.eq "1000" {to.radix.i32 8 2}}
test.case snail.test.t1402 {test.assert.eq "11111111" {to.radix.i32 255 2}}
test.case snail.test.t1403 {test.assert.eq "377" {to.radix.i32 255 8}}
test.case snail.test.t1404 {test.assert.eq "FF" {to.radix.i32 255 16}}
test.case snail.test.t1405 {test.assert.eq "1111111111111111" {to.radix.i32 65535 2}}
test.case snail.test.t1406 {test.assert.eq "177777" {to.radix.i32 65535 8}}
test.case snail.test.t1407 {test.assert.eq "FFFF" {to.radix.i32 65535 16}}
test.case snail.test.t1408 {test.assert.eq "10000000000000000" {to.radix.i32 65536 2}}
test.case snail.test.t1409 {test.assert.eq "200000" {to.radix.i32 65536 8}}
test.case snail.test.t1410 {test.assert.eq "10000" {to.radix.i32 65536 16}}
test.case snail.test.t1411 {test.assert.eq "10001" {to.radix.i32 65537 16}}
test.case snail.test.t1412 {test.assert.eq "200001" {to.radix.i32 65537 8}}
test.case snail.test.t1413 {test.assert.eq "10000000000000001" {to.radix.i32 65537 2}}
test.case snail.test.t1414 {test.assert.eq "0" {to.radix.i32 0 16}}
test.case snail.test.t1415 {test.assert.error {to.radix.i32 0 17}}
test.case snail.test.t1416 {test.assert.error {to.radix.i32 0 1}}
test.case snail.test.t1417 {test.assert.error {to.radix.i32 0 0}}
test.case snail.test.t1418 {test.assert.error {to.radix.i32 0 -1}}
test.case snail.test.t1419 {test.assert.error {to.radix.i32 "10" 16}}
test.case snail.test.t1420 {test.assert.error {to.radix.i32 10 "16"}}
test.case snail.test.t1421 {test.assert.eq {0 1 2 3 4 5 6 7 8 9} {list.generate 10}}
test.case snail.test.t1422 {
	loop {
		set r [list.generate 10]
		set s [list.shuffle $r]
		test.assert.eq $r {list.sort $s}
		if {not [= $r $s]} then {break}
	}
}
test.case snail.test.t1423 {test.assert.error {list.shuffle ""}}
test.case snail.test.t1424 {test.assert.eq "-8" {to.radix.i32 -8 10}}
test.case snail.test.t1425 {test.assert.eq "-10" {to.radix.i32 -8 8}}
test.case snail.test.t1426 {test.assert.eq "-17" {to.radix.i32 -15 8}}
test.case snail.test.t1427 {test.assert.eq "-F" {to.radix.i32 -15 16}}
test.case snail.test.t1428 {test.assert.eq "-1" {to.radix.i32 -1 2}}
test.case snail.test.t1429 {test.assert.error {token.unquote [null]}}
test.case snail.test.t1430 {test.assert.eq "{\"}" {token.unquote "{\"}"}}
test.case snail.test.t1431 {test.assert.eq "{()}" {token.unquote "{()}"}}
test.case snail.test.t1432 {test.assert.eq "{\\}" {token.unquote "{\\}"}}
test.case snail.test.t1433 {test.assert.eq "{x[]}" {token.unquote "{x[]}"}}
test.case snail.test.t1434 {test.assert.eq "%[]" {token.unquote "%[]"}}
test.case snail.test.t1435 {test.assert.eq "%$" {token.unquote "%$"}}
test.case snail.test.t1436 {test.assert.eq "x\ny" {token.unquote "x\ny"}}
test.case snail.test.t1437 {test.assert.eq foo {token.unquote "foo"}}
test.case snail.test.t1438 {test.assert.eq foo.bar.baz {token.unquote "foo.bar.baz"}}
test.case snail.test.t1439 {test.assert.eq "" {string.replace "" "" ""}}
test.case snail.test.t1440 {test.assert.eq "foo" {string.replace "foo" "" "bar"}}
test.case snail.test.t1441 {test.assert.eq "foobaz" {string.replace "foobarbaz" "bar" ""}}
test.case snail.test.t1442 {test.assert.eq {0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29} {list.sort {9 2 13 29 6 10 0 26 1 16 23 14 7 12 11 18 19 25 27 24 15 22 28 5 17 3 21 20 8 4}}}
test.case snail.test.t1443 {test.assert.eq {2147483649 2147483650 33} {list.sort {2147483649 2147483650 33}}}
test.case snail.test.t1444 {test.assert.eq {112147483650 2147483649 2147483650 33 42147483650 521474836491} {list.sort {2147483649 2147483650 33 42147483650 521474836491 112147483650}}}
test.case snail.test.t1445 {test.assert.eq {2 30 100 xa1 ya2} {list.sort {100 2 xa1 ya2 30}}}
test.case snail.test.t1379 {test.assert.null {channel.flush stdout}}
test.case snail.test.t1446 {test.assert.error {channel.flush [token.unquote [string.concat "nonexistent.channel." [rand.hex 8]]]}}
test.case snail.test.t1447 {test.assert.error {channel.flush {}}}
test.case snail.test.t1448 {
	set temp [string.concat [rand.hex 8] ".tmp"]
	set line1 [rand.hex 16]
	set line2 [rand.hex 16]
	set text [string.concat $line1 "\n" $line2]
	test.assert.null {file.write $temp $text}
	set channel [file.open $temp "r"]
	test.assert.eq [string.concat $line1 "\n"] {channel.getline $channel}
	test.assert.eq $line2 {channel.getline $channel}
	test.assert.null {channel.getline $channel}
	test.assert.null {channel.close $channel}
	test.assert.null {file.delete $temp}
}
test.case snail.test.t1449 {test.assert.error {channel.getline "C1"}}
test.case snail.test.t1450 {test.assert {token.is.list {dir.read "."}}}
test.case snail.test.t1451 {test.assert.error {dir.read [string.concat [rand.hex 8] ".dir"]}}
test.case snail.test.t1452 {test.assert.error {dir.open {}}}
test.case snail.test.t1453 {
	set channel [dir.open "."]
	test.assert {token.is.symbol $channel}
	test.assert {dict.has [info.channels] $channel}
	test.assert.null {channel.close $channel}
}
test.case snail.test.t1454 {test.assert {token.is.list [repl.history.get]}}
test.case snail.test.t1455 {test.assert {is.int [repl.history.max.get]}}
test.case snail.test.t1456 {test.assert.error {repl.history.max.set "0"}}
test.case snail.test.t1457 {test.assert.error {repl.history.max.set -1}}
test.case snail.test.t1458 {test.assert.null {repl.history.clear}}
test.case snail.test.t1459 {test.assert.error {repl.history.add {}}}
test.case snail.test.t1460 {
	set saved [repl.history.max.get]
	test.assert.eq $saved {repl.history.max.get}
	repl.history.clear
	test.assert.eq {} {repl.history.get}
	repl.history.max.set 37
	test.assert.eq 37 {repl.history.max.get}
	repl.history.max.set 38
	test.assert.eq 38 {repl.history.max.get}
	repl.history.max.set 0
	test.assert.eq 0 {repl.history.max.get}
	set test [rand.hex 8]
	repl.history.add $test
	test.assert.eq {} {repl.history.get}
	repl.history.max.set 100
	repl.history.add $test
	test.assert.eq [list $test] {repl.history.get}
	repl.history.clear
	test.assert.eq {} {repl.history.get}
	repl.history.max.set $saved
	test.assert.eq $saved {repl.history.max.get}
}
test.case snail.test.t1461 {test.assert.eq {"foo" "bar" "baz" "quux"} {string.split "foo,bar,baz,quux" ","}}
test.case snail.test.t1462 {test.assert.eq {"foo" "baz"} {string.split "foobarbaz" "bar"}}
test.case snail.test.t1463 {test.assert.eq {} {string.split "" ","}}
test.case snail.test.t1464 {test.assert.eq {"foobarbaz"} {string.split "foobarbaz" ","}}
test.case snail.test.t1465 {test.assert.eq {"foo" "" "22"} {string.split "foo,,22" ","}}
test.case snail.test.t1466 {test.assert.eq {"" ""} {string.split "," ","}}
test.case snail.test.t1467 {test.assert.eq "foo,bar,baz" {string.join {"foo" "bar" "baz"} ","}}
test.case snail.test.t1468 {test.assert.eq "" {string.join {} ","}}
test.case snail.test.t1469 {test.assert.error {dir.delete [string.concat [rand.hex 4] ".DIR"]}}
test.case snail.test.t1470 {test.assert.error {dir.delete {}}}
test.case snail.test.t1471 {test.assert.error {dir.create "."}}
test.case snail.test.t1472 {test.assert.error {dir.create {}}}
test.case snail.test.t1473 {
	set name [string.concat [rand.hex 4] ".TMP"]
	test.assert.not {file.is.dir $name}
	test.assert.null {dir.create $name}
	test.assert {file.is.dir $name}
	test.assert.error {dir.create $name}
	set file [string.concat $name "/test.txt"]
	set value [string.concat "Hello World " [rand.hex 4]]
	test.assert.null {file.write $file $value}
	test.assert.eq $value {file.read $file}
	test.assert.null {file.delete $file}
	test.assert.error {file.delete $file}
	test.assert.null {dir.delete $name}
	test.assert.not {file.is.dir $name}
	test.assert.error {dir.delete $name}
}
test.case snail.test.t1474 {
	set name1 [string.concat "F0" [rand.hex 4] ".tmp"]
	set name2 [string.concat "F1" [rand.hex 4] ".tmp"]
	set value [rand.hex 128]
	test.assert.not {file.exists $name1}
	test.assert.not {file.exists $name2}
	test.assert.null {file.write $name1 $value}
	test.assert {file.exists $name1}
	test.assert.not {file.exists $name2}
	test.assert.eq $value {file.read $name1}
	test.assert.null {file.copy $name1 $name2}
	test.assert.error {file.copy $name1 ""}
	test.assert {file.exists $name1}
	test.assert {file.exists $name2}
	test.assert.eq $value {file.read $name2}
	test.assert.null {file.delete $name1}
	test.assert.null {file.delete $name2}
}
test.case snail.test.t1475 {
	set name1 [string.concat "F0" [rand.hex 4] ".tmp"]
	set name2 [string.concat "F1" [rand.hex 4] ".tmp"]
	test.assert.error {file.copy $name1 $name2}
}
test.case snail.test.t1476 {test.assert.error {file.copy "" {}}}
test.case snail.test.t1477 {test.assert.error {file.copy {} ""}}
test.case snail.test.t1478 {test.assert {token.is.symbol [platform.type]}}
test.case snail.test.t1479 {test.assert.null {sys.no.exit {sys.exit 0}}}
test.case snail.test.t1480 {test.assert.error {sys.exit "0"}}
test.case snail.test.t1481 {test.assert.error {sys.no.exit ""}}
test.case snail.test.t1482 {test.assert.null {sys.no.exit {sys.exit}}}
test.case snail.test.t1483 {test.assert.error {sys.exit 0 0}}
test.case snail.test.t1484 {test.assert.eq 0 {sys.run "./snail - \"sys.exit 0\""}}
test.case snail.test.t1485 {test.assert {not [= 0 [sys.run "./snail - \"sys.exit 1\""]]}}
test.case snail.test.t1486 {test.assert.error {sys.run {}}}
test.case snail.test.t1487 {test.assert.error {channel.close stdprn}}
test.case snail.test.t1488 {test.assert.error {channel.close stdaux}}
test.case snail.test.t1489 {test.assert.error {channel.control "stdout" {}}}
test.case snail.test.t1490 {test.assert.error {channel.control stdout ""}}
test.case snail.test.t1491 {test.assert.error {channel.control stdout {}}}
test.case snail.test.t1492 {test.assert.error {channel.control stdout ""}}
test.case snail.test.t1493 {test.assert.error {channel.control [token.unquote [string.concat "non.existent.channel." [rand.hex 8]]] {}}}
test.case snail.test.t1494 {test.assert.error {dos.mem.alloc 0}}
test.platform.only snail.test.t1494 {djgpp}
test.case snail.test.t1495 {test.assert.null {channel.close [dos.mem.alloc 1]}}
test.platform.only snail.test.t1495 {djgpp}
test.case snail.test.t1496 {test.assert.error {proc.meta.keys {}}}
test.case snail.test.t1497 {test.assert.error {proc.meta.keys [token.unquote [string.concat "nonexistent.proc." [rand.hex 8]]]}}
test.case snail.test.t1498 {test.assert.error {proc.meta.get [token.unquote [string.concat "nonexistent.proc." [rand.hex 8]]] foo}}
test.case snail.test.t1499 {test.assert.error {proc.meta.set [token.unquote [string.concat "nonexistent.proc." [rand.hex 8]]] foo 32}}
test.case snail.test.t1500 {test.assert.null {proc.meta.get proc.meta.get [token.unquote [string.concat "nonexistent.meta." [rand.hex 8]]]}}
test.case snail.test.t1501 {
	set temp.proc.name [token.unquote [string.concat "temp.proc." [rand.hex 8]]]
	set temp.meta.name1 [token.unquote [string.concat "temp.meta." [rand.hex 8]]]
	set temp.meta.name2 [token.unquote [string.concat "temp.meta." [rand.hex 8]]]
	set value1 [string.concat "value1." [rand.hex 8]]
	set value2 [string.concat "value2." [rand.hex 8]]
	proc $temp.proc.name {} {}
	test.assert.eq {} {proc.meta.keys $temp.proc.name}
	test.assert.null {proc.meta.get $temp.proc.name $temp.meta.name1}
	test.assert.null {proc.meta.delete $temp.proc.name $temp.meta.name1}
	test.assert.null {proc.meta.set $temp.proc.name $temp.meta.name1 $value1}
	test.assert.eq [list $temp.meta.name1] {proc.meta.keys $temp.proc.name}
	test.assert.eq $value1 {proc.meta.get $temp.proc.name $temp.meta.name1}
	test.assert {dict.has [dict.get [info.about.cmd $temp.proc.name] meta] $temp.meta.name1}
	test.assert.eq $value1 {dict.get [dict.get [info.about.cmd $temp.proc.name] meta] $temp.meta.name1}
	test.assert.null {proc.meta.get $temp.proc.name $temp.meta.name2}
	test.assert.null {proc.meta.set $temp.proc.name $temp.meta.name2 $value2}
	test.assert.eq $value2 {proc.meta.get $temp.proc.name $temp.meta.name2}
	test.assert.null {proc.meta.delete $temp.proc.name $temp.meta.name2}
	test.assert.null {proc.meta.delete $temp.proc.name $temp.meta.name1}
	test.assert.eq {} {proc.meta.keys $temp.proc.name}
	test.assert.null {proc.meta.get $temp.proc.name $temp.meta.name1}
	proc.delete $temp.proc.name
}
test.case snail.test.t1502 {test.assert.error {proc.meta.delete [token.unquote [string.concat "nonexistent.proc." [rand.hex 8]]] foo}}
test.case snail.test.t1503 {test.assert.error {proc.meta.set "foo" bar baz}}
test.case snail.test.t1504 {test.assert.error {proc.meta.set proc.meta.set "foo" bar}}
test.case snail.test.t1505 {test.assert.error {proc.meta.get "foo" foo}}
test.case snail.test.t1506 {test.assert.error {proc.meta.get proc.meta.get "foo"}}
test.case snail.test.t1507 {test.assert.error {proc.meta.delete "proc.meta.delete" foo}}
test.case snail.test.t1508 {test.assert.error {proc.meta.delete proc.meta.delete "foo"}}
test.case snail.test.t1509 {
	set rand.data [rand.hex 4]
	set channel [dos.mem.alloc 16]
	test.assert {token.is.symbol $channel}
	test.assert {is.int [channel.control $channel {selector}]}
	test.assert {is.int [channel.control $channel {segment}]}
	test.assert.eq 16 {channel.control $channel {size}}
	test.assert.null {channel.control $channel {byte.set 0 65}}
	test.assert.eq 65 {channel.control $channel {byte.get 0}}
	test.assert.eq "A" {channel.read $channel 16}
	test.assert.null {channel.write $channel $rand.data}
	test.assert.eq $rand.data {channel.read $channel 16}
	test.assert.null {channel.close $channel}
}
test.platform.only snail.test.t1509 {djgpp}
test.case snail.test.t1510 {test.assert.eq 0 {from.radix.i32 "0" 2}}
test.case snail.test.t1511 {test.assert.eq 0 {from.radix.i32 "0" 8}}
test.case snail.test.t1512 {test.assert.eq 0 {from.radix.i32 "0" 10}}
test.case snail.test.t1513 {test.assert.eq 0 {from.radix.i32 "0" 16}}
test.case snail.test.t1514 {test.assert.eq 2 {from.radix.i32 "10" 2}}
test.case snail.test.t1515 {test.assert.eq 8 {from.radix.i32 "10" 8}}
test.case snail.test.t1516 {test.assert.eq 16 {from.radix.i32 "10" 16}}
test.case snail.test.t1517 {test.assert.eq -2 {from.radix.i32 "-10" 2}}
test.case snail.test.t1518 {test.assert.eq -8 {from.radix.i32 "-10" 8}}
test.case snail.test.t1519 {test.assert.eq -16 {from.radix.i32 "-10" 16}}
test.case snail.test.t1520 {test.assert.eq 10 {from.radix.i32 "10" 10}}
test.case snail.test.t1521 {test.assert.eq -10 {from.radix.i32 "-10" 10}}
test.case snail.test.t1522 {test.assert.eq -127 {from.radix.i32 "-177" 8}}
test.case snail.test.t1523 {test.assert.eq -375 {from.radix.i32 "-177" 16}}
test.case snail.test.t1524 {test.assert.eq -255 {from.radix.i32 "-FF" 16}}
test.case snail.test.t1525 {test.assert.error {from.radix.i32 "0" 1}}
test.case snail.test.t1526 {test.assert.error {from.radix.i32 "0" 17}}
test.case snail.test.t1527 {test.assert.error {from.radix.i32 "" 10}}
test.case snail.test.t1528 {test.assert.error {from.radix.i32 "z" 10}}
test.case snail.test.t1529 {test.assert.error {from.radix.i32 "1f" 8}}
test.case snail.test.t1530 {test.assert.error {from.radix.i32 10 10}}
test.case snail.test.t1531 {test.assert.error {from.radix.i32 "10" hex}}
test.case snail.test.t1532 {
	puts [string.concat "Detected DOS version " [dos.version]]
}
test.platform.only snail.test.t1532 {djgpp}
test.case snail.test.t1533 {
	set saved [repl.read.script.get]
	test.assert {token.is.list $saved}
	test.assert.eq $saved {repl.read.script.get}
	set value [rand.hex 8]
	set script [list pass $value]
	test.assert.null {repl.read.script.set $script}
	test.assert.eq $script {repl.read.script.get}
	test.assert.eq [string.concat $value "\n"] {repl.read}
	test.assert.eq [string.concat $value "\n"] {repl.read}

	set script {null}
	test.assert.null {repl.read.script.set $script}
	test.assert.eq $script {repl.read.script.get}
	test.assert.null {repl.read}
	test.assert.null {repl.read}

	test.assert.null {repl.read.script.set $saved}
	test.assert.eq $saved {repl.read.script.get}
}
test.case snail.test.t1534 {test.assert.error {repl.read.script.set [null]}}
test.case snail.test.t1535 {
	test.assert {token.is.list [sys.at.exit.list]}
	set value1 [rand.hex 4]
	set script1 [list pass $value1]
	set value2 [rand.hex 4]
	set script2 [list pass $value2]
	test.assert.not {list.contains [sys.at.exit.list] $script1}
	test.assert.not {list.contains [sys.at.exit.list] $script2}
	test.assert.null {sys.at.exit $script1}
	test.assert {list.contains [sys.at.exit.list] $script1}
	test.assert.not {list.contains [sys.at.exit.list] $script2}
	test.assert.null {sys.at.exit $script2}
	test.assert {list.contains [sys.at.exit.list] $script1}
	test.assert {list.contains [sys.at.exit.list] $script2}
	test.assert.error {sys.at.exit.remove [list.length [sys.at.exit.list]]}
	test.assert.null {sys.at.exit.remove [list.find [sys.at.exit.list] $script1]}
	test.assert.not {list.contains [sys.at.exit.list] $script1}
	test.assert {list.contains [sys.at.exit.list] $script2}
	test.assert.null {sys.at.exit.remove [list.find [sys.at.exit.list] $script2]}
	test.assert.not {list.contains [sys.at.exit.list] $script1}
	test.assert.not {list.contains [sys.at.exit.list] $script2}
}
test.case snail.test.t1536 {test.assert.error {sys.at.exit ""}}
test.case snail.test.t1537 {test.assert.error {sys.at.exit.remove {}}}
test.case snail.test.t1538 {test.assert.error {sys.at.exit.remove -1}}
test.case snail.test.t1539 {test.assert.error {sys.at.exit.remove [list.length [sys.at.exit.list]]}}
test.case snail.test.t1540 {test.assert {token.is.list [global.get sys.args]}}
test.case snail.test.t1541 {test.assert.not {> 0 [list.length [global.get sys.args]]}}
test.case snail.test.t1542 {test.assert {token.is.quoted [list.at [global.get sys.args] 0]}}
test.case snail.test.t1543 {test.assert {list.contains [info.globals] sys.args}}
test.case snail.test.t1544 {
	set file.name [string.concat [rand.hex 4] ".tmp"]
	set global.name [token.unquote [string.concat "test.global." [rand.hex 4]]]
	set value [rand.hex 8]
	set script [string.concat "#!shebang\n" [token.list.body [list global.set $global.name $value]]]
	test.assert.null {file.write $file.name $script}
	test.assert.null {global.get $global.name}
	test.assert.not {list.contains [info.globals] $global.name}
	test.assert.null {file.run $file.name}
	test.assert {list.contains [info.globals] $global.name}
	test.assert.eq $value {global.get $global.name}
	test.assert.null {global.delete $global.name}
	test.assert.not {list.contains [info.globals] $global.name}
	test.assert.null {global.get $global.name}
	test.assert {file.exists $file.name}
	test.assert.null {file.delete $file.name}
	test.assert.not {file.exists $file.name}
}
test.case snail.test.t1545 {test.assert.error {global.delete {}}}
test.case snail.test.t1546 {
	set file.name [string.concat [rand.hex 4] ".tmp"]
	set script "#invalid_shebang"
	test.assert.null {file.write $file.name $script}
	test.assert.error {file.run $file.name}
	test.assert {file.exists $file.name}
	test.assert.null {file.delete $file.name}
	test.assert.not {file.exists $file.name}
}
test.case snail.test.t1547 {test.assert.eq {"0" "1" "10" "12" "31" "88" "9" 0 1 9 10 12 31 88} {list.sort {0 "0" 10 "10" 12 "12" 31 "31" 88 "88" 9 "9" 1 "1"}}}
test.case snail.test.t1548 {test.assert {token.is.dict [sys.environ]}}
test.case snail.test.t1549 {test.assert.error {time.local "0"}}
test.case snail.test.t1550 {test.assert.error {time.utc "0"}}
test.case snail.test.t1551 {test.assert.eq 1970 {dict.get [time.utc 0] year}}
test.case snail.test.t1552 {test.assert.eq 0 {dict.get [time.local 0] sec}}
test.case snail.test.t1553 {test.assert.eq "1970-01-01 00:00:00" {time.iso8601.utc 0}}
test.case snail.test.t1554 {test.assert.eq "2009-02-13 23:31:30" {time.iso8601.utc 1234567890000}}
test.case snail.test.t1555 {test.assert.eq 1 {dict.get [time.utc 1514764800000] dow}}
test.case snail.test.t1556 {test.assert.eq 7 {dict.get [time.utc 1522540800000] dow}}
test.case snail.test.t1557 {test.assert.not {time.is.leap.year 1900}}
test.case snail.test.t1558 {test.assert {time.is.leap.year 2000}}
test.case snail.test.t1559 {test.assert.not {time.is.leap.year 2001}}
test.case snail.test.t1560 {test.assert.not {time.is.leap.year 2002}}
test.case snail.test.t1561 {test.assert.not {time.is.leap.year 2003}}
test.case snail.test.t1562 {test.assert {time.is.leap.year 2004}}
test.case snail.test.t1563 {test.assert.eq 28 {time.month.length 1900 2}}
test.case snail.test.t1564 {test.assert.eq 29 {time.month.length 2000 2}}
test.case snail.test.t1565 {
	set ts [time.now]
	set dt [time.local $ts]
	test.assert.eq $ts {time.make.local $dt}
}
test.case snail.test.t1566 {test.assert.error {time.make.local 0}}
test.case snail.test.t1567 {test.assert.error {time.make.local %{}}}
test.case snail.test.t1568 {test.assert.error {time.make.local %{year 2000}}}
test.case snail.test.t1569 {test.assert.error {time.make.local %{year 2000 month 1}}}
test.case snail.test.t1570 {test.assert.error {time.make.local %{year 2000 month 1 dom 1}}}
test.case snail.test.t1571 {test.assert.error {time.make.local %{year 2000 month 1 dom 1 hour 0}}}
test.case snail.test.t1572 {test.assert.error {time.make.local %{year 2000 month 1 dom 1 hour 0 min 0}}}
test.case snail.test.t1573 {test.assert.error {time.make.local %{year 2000 month 1 dom 1 hour 0 min 0 sec "0"}}}
test.case snail.test.t1574 {test.assert.error {time.make.local %{year 2000 month 1 dom 1 hour 0 min 0 sec 99}}}
test.case snail.test.t1575 {test.assert.error {time.make.local %{year 2000 month 1 dom 1 hour 0 min 0 sec -1}}}
test.case snail.test.t1576 {
	set ts1 [time.now]
	set dt1 [time.local $ts1]
	set ts2 [* [/ $ts1 1000] 1000]
	set dt2 [dict.del $dt1 millis]
	test.assert.eq $ts2 {time.make.local $dt2}
}
test.case snail.test.t1577 {test.assert.eq %{foo 12} {dict.del %{foo 12 bar 13} bar}}
test.case snail.test.t1578 {test.assert.eq %{} {dict.del %{foo 12} foo}}
test.case snail.test.t1579 {test.assert.eq %{} {dict.del %{} quux}}
test.case snail.test.t1580 {test.assert.eq %{foo bar} {dict.del %{foo bar} quux}}
test.case snail.test.t1581 {test.assert.error {dict.del {} foo}}
test.case snail.test.t1582 {test.assert.error {% 1 0}}
test.case snail.test.t1583 {test.assert.error {% 1 0}}
test.case snail.test.t1584 {test.assert.eq 0 {% 188 2}}
test.case snail.test.t1585 {test.assert.eq 1 {% 189 2}}
test.case snail.test.t1586 {test.assert.error {% "1" 0}}
test.case snail.test.t1587 {test.assert.error {% 1 "2"}}
test.case snail.test.t1588 {test.assert {time.valid [time.utc 0]}}
test.case snail.test.t1589 {test.assert {time.valid [time.local 0]}}
test.case snail.test.t1590 {test.assert {time.valid [time.local [time.now]]}}
test.case snail.test.t1591 {test.assert {time.valid [time.utc [time.now]]}}
test.case snail.test.t1592 {test.assert.eq "1970-01-01 00:00:00" {time.iso8601 [time.iso8601.parse "1970-01-01 00:00:00"]}}
test.case snail.test.t1593 {test.assert.eq "2000-02-29 23:59:59" {time.iso8601 [time.iso8601.parse "2000-02-29 23:59:59"]}}
test.case snail.test.t1594 {test.assert.eq {} {list.reverse {}}}
test.case snail.test.t1595 {test.assert.eq {baz bar foo} {list.reverse {foo bar baz}}}
test.case snail.test.t1596 {test.assert.error {list.reverse "foo bar baz"}}
test.case snail.test.t1597 {test.assert {token.is.quoted [file.getcwd]}}
test.case snail.test.t1598 {
	set cur [file.getcwd]
	test.assert.null {file.setcwd $cur}
	test.assert.eq $cur {file.getcwd}
}
test.case snail.test.t1599 {test.assert.error {file.setcwd [string.concat [rand.hex 8] ".nonexistent"]}}
test.case snail.test.t1600 {test.assert.error {file.setcwd {}}}
test.case snail.test.t1601 {test.assert.eq "414243313233" {hex.encode "ABC123"}}
test.case snail.test.t1602 {
	set temp [string.concat [rand.hex 4] ".tmp"]
	set value "Hello World!"
	file.write $temp $value
	test.assert.eq [hex.encode $value] {file.read.hex $temp}
	file.delete $temp
}
test.case snail.test.t1603 {test.assert.error {file.read.hex [string.concat [rand.hex 4] ".nonexistent"]}}
test.case snail.test.t1604 {test.assert.error {hex.encode {}}}
test.case snail.test.t1605 {test.assert.error {file.read.hex {}}}
test.case snail.test.t1606 {test.assert.eq "Abacus$15" {hex.decode [hex.encode "Abacus$15"]}}
test.case snail.test.t1607 {test.assert.eq "" {hex.encode ""}}
test.case snail.test.t1608 {test.assert.eq "" {hex.decode ""}}
test.case snail.test.t1609 {test.assert.eq "" {hex.decode "00"}}
test.case snail.test.t1610 {test.assert.error {hex.decode "0G"}}
test.case snail.test.t1611 {test.assert.error {hex.decode {}}}
test.case snail.test.t1612 {
	set temp [string.concat [rand.hex 4] ".tmp"]
	set hex "0001020300040506F0F9FFfa"
	test.assert.null {file.write.hex $temp $hex}
	test.assert.eq [string.upper $hex] {file.read.hex $temp}
	test.assert.eq [string.upper $hex] {file.read.hex $temp}
	test.assert.null {file.delete $temp}
}
test.case snail.test.t1613 {
	set temp [string.concat [rand.hex 4] ".tmp"]
	set hex ""
	test.assert.null {file.write.hex $temp $hex}
	test.assert.eq $hex {file.read.hex $temp}
	test.assert.eq $hex {file.read.hex $temp}
	test.assert.null {file.delete $temp}
}
test.case snail.test.t1614 {test.assert.eq "FF" {hex.encode [hex.decode "FF"]}}
test.case snail.test.t1615 {
	set temp [string.concat [rand.hex 4] ".tmp"]
	set hex "0001020300040506F0F9FF"
	test.assert.null {file.write.hex $temp $hex}
	set chan [file.open $temp "r"]
	test.assert.eq $hex {channel.read.hex $chan 128}
	test.assert.null {channel.read.hex $chan 128}
	test.assert.null {channel.close $chan}
	test.assert.null {file.delete $temp}
}
test.case snail.test.t1616 {test.assert.error {file.write.hex "." ""}}
test.case snail.test.t1617 {test.assert.error {file.write.hex "." {}}}
test.case snail.test.t1618 {test.assert.error {file.write.hex {} ""}}
test.case snail.test.t1619 {
	set temp [string.concat [rand.hex 4] ".tmp"]
	test.assert.not {file.exists $temp}
	test.assert.error {file.write.hex $temp "0"}
	test.assert.not {file.exists $temp}
	test.assert.error {file.write.hex $temp "0G"}
	test.assert.not {file.exists $temp}
	test.assert.error {file.write.hex $temp "0fFfF"}
	test.assert.not {file.exists $temp}
	test.assert.error {file.write.hex $temp "01FAaFH"}
	test.assert.not {file.exists $temp}
}
test.case snail.test.t1620 {test.assert.eq "FF" {hex.encode [hex.decode "ff"]}}
test.case snail.test.t1621 {test.assert.error {hex.decode "0"}}
test.case snail.test.t1622 {test.assert.error {hex.decode "!!"}}
test.case snail.test.t1623 {test.assert.error {hex.decode "::"}}
test.case snail.test.t1624 {test.assert.eq "EFCDAB9078563412" {hex.reverse "1234567890ABCDEF"}}
test.case snail.test.t1625 {test.assert.eq "3412" {hex.reverse "1234"}}
test.case snail.test.t1626 {test.assert.eq "" {hex.reverse ""}}
test.case snail.test.t1627 {test.assert.error {hex.reverse {}}}
test.case snail.test.t1628 {test.assert.error {hex.reverse "0"}}
test.case snail.test.t1629 {test.assert.null {disk.sync}}
test.case snail.test.t1630 {test.assert.eq 1 {math.and.u32 99 1}}
test.case snail.test.t1631 {test.assert.eq 0 {math.and.u32 98 1}}
test.case snail.test.t1632 {test.assert.eq 99 {math.or.u32 98 1}}
test.case snail.test.t1633 {test.assert.eq 99 {math.or.u32 99 1}}
test.case snail.test.t1634 {test.assert.eq 1 {math.xor.u32 99 98}}
test.case snail.test.t1635 {test.assert.eq 4294967294 {math.not.u32 1}}
test.case snail.test.t1636 {test.assert.eq 4294967295 {math.not.u32 0}}
test.case snail.test.t1637 {test.assert.eq 0 {math.and.u32 0 0}}
test.case snail.test.t1638 {test.assert.error {math.and.u32 "0" 0}}
test.case snail.test.t1639 {test.assert.error {math.and.u32 0 "0"}}
test.case snail.test.t1640 {test.assert.error {math.or.u32 "0" 0}}
test.case snail.test.t1641 {test.assert.error {math.or.u32 0 "0"}}
test.case snail.test.t1642 {test.assert.error {math.and.u32 -1 0}}
test.case snail.test.t1643 {test.assert.error {math.and.u32 0 -1}}
test.case snail.test.t1644 {test.assert.error {math.xor.u32 0 "0"}}
test.case snail.test.t1645 {test.assert.error {math.xor.u32 "0" 0}}
test.case snail.test.t1646 {test.assert.error {math.not.u32 "0"}}
test.case snail.test.t1647 {test.assert.error {math.or.u32 -1 0}}
test.case snail.test.t1648 {test.assert.error {math.or.u32 0 -1}}
test.case snail.test.t1649 {test.assert.error {math.xor.u32 0 -1}}
test.case snail.test.t1650 {test.assert.error {math.xor.u32 -1 0}}
test.case snail.test.t1651 {test.assert.error {math.not.u32 -1}}
test.case snail.test.t1652 {test.assert.eq 77 {math.not.u32 [math.not.u32 77]}}
test.case snail.test.t1653 {test.assert.not {is.hex {}}}
test.case snail.test.t1654 {test.assert {is.hex ""}}
test.case snail.test.t1655 {test.assert {is.hex "FF"}}
test.case snail.test.t1656 {test.assert {is.hex "ff"}}
test.case snail.test.t1657 {test.assert.not {is.hex "gg"}}
test.case snail.test.t1658 {test.assert {is.hex "00"}}
test.case snail.test.t1659 {test.assert.not {is.hex "000"}}
test.case snail.test.t1660 {test.assert.null {channel.write.hex stdout [hex.encode "Hello World!\n"]}}
test.case snail.test.t1661 {test.assert.error {channel.write.hex [token.unquote [string.concat "nonexistent.channel." [rand.hex 8]]] "1234567890ABCDEF"}}
test.case snail.test.t1662 {test.assert.error {channel.write.hex stdout "0"}}
test.case snail.test.t1663 {test.assert.null {channel.write.hex stdout ""}}
test.case snail.test.t1664 {test.assert.error {channel.write.hex stdout {}}}
test.case snail.test.t1665 {test.assert.error {channel.write.hex "stdout" ""}}
test.case snail.test.t1666 {
	set mem.buf [dos.mem.fixed 64000 [hex A000]]
	test.assert.eq 64000 {channel.control $mem.buf {selector.limit}}
	test.assert.eq [hex A0000] {channel.control $mem.buf {selector.base}}
	test.assert.null {channel.close $mem.buf}
}
test.platform.only snail.test.t1666 {djgpp}
test.case snail.test.t1667 {test.assert.eq "" {hex.zeroes 0}}
test.case snail.test.t1668 {test.assert.error {hex.zeroes -1}}
test.case snail.test.t1669 {test.assert.error {hex.zeroes {}}}
test.case snail.test.t1670 {test.assert.eq "00" {hex.zeroes 1}}
test.case snail.test.t1671 {test.assert.eq 666 {hex.length [hex.zeroes 666]}}
test.case snail.test.t1672 {test.assert.eq 64000 {hex.length [hex.zeroes 64000]}}
