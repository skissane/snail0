proc module.cmds {$name} {
	arg.must.symbol name
	if {module.exists.unloaded $name} then {module.load $name}
	set prefix [string.concat [token.quote $name] "."]
	set r {}
	foreach cmd [info.cmds] {
		if {string.starts.with [token.quote $cmd] $prefix} then {
			set r [list.add $r $cmd]
		}
	}
	list.sort $r
}

proc list.find.at {$list $what} {
	set i 0
	set length [list.length $list]
	while {< $i $length} {
		set e [list.at $list $i]
		if {= $e $what} then {return $i}
		set i [+ $i 1]
	}
	return ""
}

proc file.exists {$path} {
	catch {
		file.stat $path
		pass t
	} ignored { pass f }
}

proc file.is.type {$path $type} {
	catch {
		set stat [file.stat $path]
		= [dict.get $stat type] $type
	} ignored {pass f}
}

proc token.is.quoted {$token} {= [token.classify $token] Q}
proc token.is.symbol {$token} {= [token.classify $token] U}
proc token.is.dict {$token} {= [token.classify $token] D}
proc token.is.list {$token} {= [token.classify $token] L}
proc token.is.exec {$token} {= [token.classify $token] X}
proc token.is.newline {$token} {= [token.classify $token] N}
proc token.is.null {$token} {= [token.classify $token] Z}
proc token.is.var {$token} {= [token.classify $token] V}

proc arg.must.quoted {$name} {
	if {not [token.is.quoted [var.get.up 1 $name]]} then {
		error [string.concat "argument $" $name " must be quoted string (in: " [frame.cmd.up 1] ")"]
	}
}

proc arg.must.symbol {$name} {
	if {not [token.is.symbol [var.get.up 1 $name]]} then {
		error [string.concat "argument $" $name " must be a symbol (in: " [frame.cmd.up 1] ")"]
	}
}

proc arg.must.list {$name} {
	if {not [token.is.list [var.get.up 1 $name]]} then {
		error [string.concat "argument $" $name " must be a list (in: " [frame.cmd.up 1] ")"]
	}
}

proc arg.must.int {$name} {
	if {not [is.int [var.get.up 1 $name]]} then {
		error [string.concat "argument $" $name " must be an integer (in: " [frame.cmd.up 1] ")"]
	}
}

proc file.is.blk {$path} {file.is.type $path blk}
proc file.is.chr {$path} {file.is.type $path chr}
proc file.is.dir {$path} {file.is.type $path dir}
proc file.is.fifo {$path} {file.is.type $path fifo}
proc file.is.reg {$path} {file.is.type $path reg}
proc file.is.lnk {$path} {file.is.type $path lnk}
proc file.is.sock {$path} {file.is.type $path sock}

global.set module.load.path {"./autoload"}
global.set module.loaded %{}

proc not {$bool} {if {pass $bool} then {pass f} else {pass t}}
proc not.null {$v} {not [is.null $v]}

proc string.contains {$haystack $needle} {not.null [string.find $haystack $needle]}

proc module.name {$name} {
	arg.must.symbol name
	set quoted [token.quote $name]
	if {not [string.contains $quoted "."]} then {
		null
	} else {
		token.unquote [string.left $quoted [string.find.rev $quoted "."]]
	}
}

proc module.find.path {$name} {
	while {not.null $name} {
		foreach path [global.get module.load.path] {
			set fpath [string.concat $path "/" [string.replace [token.quote $name] "." "/"] ".snail"]
			if {file.is.reg $fpath} then {return $fpath}
		}
		set name [module.name $name]
	}
	null
}

proc module.is.loaded {$name} {
	arg.must.symbol name
	nvl [dict.get [global.get module.loaded] $name] f
}

proc module.set.loaded {$name} {
	arg.must.symbol name
	global.set module.loaded [dict.set [global.get module.loaded] $name t]
}

proc module.exists {$name} {
	arg.must.symbol name
	if {module.is.loaded $name} then {return t}
	not.null [module.find.path $name]
}

proc module.exists.unloaded {$name} {
	arg.must.symbol name
	if {module.is.loaded $name} then {return f}
	not.null [module.find.path $name]
}

proc module.load {$name} {
	arg.must.symbol name
	if {module.is.loaded $name} then {return [null]}
	set path [module.find.path $name]
	if {is.null $path} then {
		error [string.concat "no file found for module '" $name "'"]
	}
	catch {
		file.run $path
	} e {
		error [string.concat "error loading file '" $path "' for module '" $name  "': " $e]
	}
	module.set.loaded $name
	null
}

proc apply {$cmd $args} {
	arg.must.symbol cmd
	arg.must.list args
	eval [list.concat [list $cmd] $args]
}

proc unknown {$cmd $args} {
	if {token.is.symbol $cmd} then {
		set module [module.name $cmd]
		if {not.null $module} then {
			if {module.exists.unloaded $module} then {
				module.load $module
				return [apply $cmd $args]
			}
		}
	}
	error [string.concat "unknown command " [token.quote [token.quote $cmd]]]
}

proc help {} {
	puts "Welcome to Snail interpreter online help"
	puts "For list of valid commands, type: help.cmds"
	puts ""
}

proc module.load.for {$name} {
	arg.must.symbol name
	set module [module.name $name]
	if {not.null $module} then {
		if {module.exists.unloaded $module} then {module.load $module}
	}
}

proc proc.exists {$name} {
	arg.must.symbol name
	module.load.for $name
	not.null [info.about.cmd $name]
}

proc string.is.empty {$string} {
	arg.must.quoted string
	= 0 [string.length $string]
}

proc channel.read.line {$channel} {
	set line ""
	loop {
		set r [channel.read $channel 1]
		if {is.null $r} then {return [if {string.is.empty $line} then {null} else {pass $line}]}
		if {= $r "\n"} then {return $line}
		set line [string.concat $line $r]
	}
}

proc prompt {$prompt} {
	arg.must.quoted prompt
	puts.nonewline $prompt
	channel.flush stdout
	channel.read.line stdin
}

proc prompt.yesno {$prompt} {
	loop {
		set response [prompt [string.concat $prompt " (Y/N)? "]]
		if {is.null $response} then {
			puts ""
			puts "Got EOF - assuming response NO"
			return f
		}
		set response [string.upper [string.trim $response]]
		if {= $response "Y"} then {return t}
		if {= $response "YES"} then {return t}
		if {= $response "N"} then {return f}
		if {= $response "NO"} then {return f}
		puts "Invalid response - please answer YES or NO"
	}
}

proc string.strip.prefix {$str $prefix} {
	if {string.starts.with $str $prefix} then {
		string.skip $str [string.length $prefix]
	} else {
		pass $str
	}
}

proc string.strip.suffix {$str $suffix} {
	if {string.ends.with $str $suffix} then {
		string.sub $str 0 [- [string.length $str] [string.length $suffix]]
	} else {
		pass $str
	}
}

proc string.strip.circumfix {$str $prefix $suffix} {
	string.strip.suffix [string.strip.prefix $str $prefix] $suffix
}

proc token.list.body {$list} {
	arg.must.list list
	string.strip.circumfix [token.quote $list] "{" "}"
}

proc catching {$code} {
	set caught [null]
	catch {eval.up 1 $code} e {set caught $e}
	pass $caught
}

proc string.lpad {$string $char $len} {
	arg.must.quoted string
	arg.must.quoted char
	arg.must.int len
	set r $string
	while {< [string.length $r] $len} {
		set r [string.concat $char $r]
	}
	pass $r
}

proc string.rpad {$string $char $len} {
	arg.must.quoted string
	arg.must.quoted char
	arg.must.int len
	set r $string
	while {< [string.length $r] $len} {
		set r [string.concat $r $char]
	}
	pass $r
}

proc uuid.generate {} {
	loop {
		set y [string.skip [rand.hex 1] 1]
		if {or {= $y "8"} {= $y "9"} {= $y "A"} {= $y "B"}} then {break}
	}
	string.concat [rand.hex 8] "-" [rand.hex 4] "-4" [rand.hex 3] "-" $y [rand.hex 3] "-" [rand.hex 12]
}

proc list.contains {$list $elem} {not.null [list.find $list $elem]}

proc math.bits.u32 {$n} {- 32 [math.clz.u32 $n]}

proc repeat {$times $code} {
	set i 0
	while {< $i $times} {
		eval.up 1 $code
		set i [+ 1 $i]
	}
}

proc list.repeat {$times $code} {
	set r {}
	repeat $times {set r [list.add $r [eval.up 1 $code]]}
	pass $r
}

proc histogram {$list} {
	set r %{}
	foreach e $list {
		set r [dict.set $r $e [+ 1 [nvl [dict.get $r $e] 0]]]
	}
	pass $r
}

proc dict.as.sorted.list {$dict} {
	set r {}
	foreach key [list.sort [dict.keys $dict]] {
		set r [list.concat $r [list $key [dict.get $dict $key]]]
	}
	pass $r
}

proc dict.values {$dict} {
	set r {}
	foreach key [list.sort [dict.keys $dict]] {
		set r [list.add $r [dict.get $dict $key]]
	}
	pass $r
}

proc math.abs {$n} {
	if {< $n 0} then {- $n} else {pass $n}
}

proc list.generate {$n} {
	arg.must.int n
	if {< $n 0} then {error "argument cannot be negative"}
	set r {}
	set i 0
	while {< $i $n} {
		set r [list.add $r $i]
		set i [+ 1 $i]
	}
	pass $r
}

proc dir.read {$path} {
	set channel [dir.open $path]
	set r {}
	loop {
		set entry [channel.getline $channel]
		if {is.null $entry} then {break}
		set r [list.add $r $entry]
	}
	channel.close $channel
	pass $r
}
